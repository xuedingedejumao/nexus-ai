1. 在引入tika和minio时遇到循环依赖报错问题，尝试了排除某些包，以及调整依赖版本等等，我询问了ai，ai的回答一直是冲突依赖，并不能解决我的问题。于是我在检查代码，发现是在初始化创建minio桶时递归调用了创建桶的函数，导致栈溢出报错。解决方法是修改初始化桶的逻辑，避免递归调用。
2. 在开发 NexusAI 的对象存储模块时，我设计了一个‘自愈’机制：希望系统启动时能自动检测 MinIO 中是否存在指定的 Bucket，如果不存在就自动创建。

当时我为了图方便，直接在 MinioConfig 配置类中使用了 @PostConstruct 注解，试图在 Bean 初始化阶段直接调用 minioClient() 方法来执行建桶逻辑。结果程序启动时直接报错，抛出了 BeanCurrentlyInCreationException。

经过分析，我意识到这是一个经典的**循环依赖（Circular Dependency）**场景： Spring 容器正在创建 MinioConfig 这个 Bean，但在它的初始化方法（PostConstruct）执行完成前，我又在方法内部请求获取 minioClient 这个 Bean。而 minioClient 的生产工厂方法又定义在 MinioConfig 里。这就导致了 Spring 陷入了‘先有鸡还是先有蛋’的死锁状态。

我的解决方案是利用 Spring 的事件机制进行解耦： 我弃用了 @PostConstruct，转而实现了一个 ApplicationRunner Bean。 这一改动将‘Bean 的定义与创建’和‘业务逻辑的执行’彻底分离开了。ApplicationRunner 保证了只有在 Spring 容器完全启动、所有 Bean 都加载完毕后，才去执行 Bucket 的检查逻辑。

最终结果：不仅完美解决了循环依赖报错，还提升了系统的启动稳定性，确保了基础设施初始化逻辑不会干扰核心容器的构建过程。”


3. 在引入消息队列kafka时，遇到了查找失败的问题，我检查了数据库中的记录，发现是在创建entity时，由于java使用的命名标准为小驼峰而数据库是下划线命名，导致了字段无法映射。我通过在dto的字段上添加注解解决了这个问题。

4. 它不记得当前对话上下文中提到的聊天内容，只对文件敏感   添加了ChatMemory（MessageWindowChatMemory） 并且优化了提示词，让模型分别从上下文和事实两方面获取信息  并且为了防止redis对于上下文信息的拦截，对其添加了一个过滤器，避免其过滤重要信息